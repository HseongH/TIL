# 전체 정리

## 1. 변수

### 1.1 var, let, const 차이

1. var

   - 함수 레벨 스코프
   - 호이스팅이 발생한다.
   - es5까지 변수를 선언할 수 있는 유일한 키워드이다.
   - 전역으로 선언 시 전역 객체 window의 프로퍼티가 된다.
   - 변수 선언 시 초기화가 같이 수행된다.
   - 동일한 이름의 변수도 재선언이 가능하다.

2. let과 const
   - 블록 레벨 스코프
   - 호이스팅이 발생하지 않는 것처럼 동작한다.
   - es6에서 변수를 선언할 수 있는 키워드로 추가되었다.
   - 전역으로 선언하여도 window의 내부 프로퍼티가 되지 않는다.
   - 변수 선언과 초기화가 따로 수행된다.
   - let은 선언 후 변수의 값을 변경할 수 있지만 const는 상수 선언 키워드로 변수에 할당된 값을 변경할 수 없다.
   - 동일한 이름의 변수를 재선언할 수 없다.

### 1.2 변수 타입

크게 원시 타입과 객체 타입으로 구분된다.

원시 타입에는 Number, String, Boolean, null, undefined, symbol 타입이 존재한다. 자바스크립트는 객체 지향 언어로 6가지 원시 타입을 제외한 모든 값이 객체 타입이다.

1. Number
   - 자바스크립트에서는 정수를 위한 타입이 존재하지 않는다. 모든 수를 8바이트 크기의 실수로 저장한다. 따라서 정수끼리의 연산 결과로 실수가 나오는 것이 가능하다.
2. String
   - '', "", ``로 감싸진 타입이다. 텍스트를 표시할 때 주로 사용한다.
3. Boolean
   - 참, 거짓을 나타내는 데이터 타입이다. 제어문에서 많이 사용된다.
4. null
   - 명시적으로 값이 없음을 나타낼 때 사용하는 데이터 타입이다.
5. undefined
   - 어떠한 식별자에 한 번도 값이 할당된 적이 없음을 나타낸다. var 키워드로 변수 선언 시 자바스크립트 엔진이 변수 초기화를 위해 할당하는 값으로 개발자가 명시적으로 값이 없음을 나타내기 위해 사용하면 혼란을 야기할 수 있다.
6. symbol
   - es6에서 새로 추가된 데이터 타입으로 유일무이한 값을 나타낼 때 사용하는 데이터 타입이다. 주로 객체 내부의 유일한 프로퍼티를 생성하기 위해 사용한다.

### 1.3 원시 타입과 객체 타입의 차이

1. 원시 타입
   - 하나의 원시 타입은 하나의 실생활의 데이터를 나타낸다.
   - 변수에 원시 타입의 값을 할당하면 변수는 해당 값이 존재하는 메모리 주소를 참조한다.
2. 객체 타입
   - 여러 개의 데이터의 집합으로 구성된다.
   - 변수에 객체 타입의 값을 할당하면 실제 데이터가 존재하는 공간의 주소를 참조하는 메모리 공간의 주소를 참조하게 된다.
   - const 키워드로 선언된 변수도 객체 타입이라면 객체 내부 프로퍼티 값을 변경할 수 있다.

---

## 2. 함수

### 2.1 자바스크립트의 함수 특징

자바스크립트에서 함수는 일급 객체로 분류된다.

함수의 매개변수로 전달이 가능하고, 함수의 리턴 값으로 사용할 수 있으며 데이터 내부의 값으로 사용할 수 있는 데이터를 일급 객체라고 부른다.

### 2.2 클로저

함수의 내부 값을 다른 곳에서 참조하고 있으면 함수의 실행이 종료되어도 가비지 콜렉터에 의해 할당이 해제되지 않는 특성을 말한다.

클로저를 이용하면 함수의 스코프 밖에서도 함수 내부의 값들을 사용할 수 있다.

### 2.3 function 키워드와 arrow function의 차이

function 키워드로 선언된 함수는 생성자 함수로 사용할 수 있고, 클로저를 생성하며, arguments 객체를 가진다.

arrow function의 경우 생성자 함수로 사용할 수 없으며, arguments 객체를 사용할 수 없다는 특징이 있다.

### 2.4 생성자 함수

동일한 프로퍼티를 가지는 객체를 생성할 목적으로 사용되는 함수이다. this 키워드를 사용해 생성할 객체(인스턴스)의 내부 값을 정의하며 return을 사용하지 않아도 생성된 객체(인스턴스)가 암묵적으로 return 된다. 이때 return 키워드를 사용하여 다른 값을 반환하게 되면 그 값이 return 되므로 생성자 함수에서는 return을 사용하지 않는 것이 좋다.

### 2.5 this 바인딩

this는 객체를 가리키는 키워드로 함수에서도 사용할 수 있는데 함수의 생성 목적에 따라 바인딩되는 값이 달라진다.

function 키워드로 생성된 일반 함수에서 this는 전역 객체 window(node의 경우 global)를 가리킨다.

생성자 함수에서 this는 생성자 함수가 생성할 객체(인스턴스)를 가리킨다.

arrow function으로 선언된 함수에서 this는 함수의 상위 스코프를 가리킨다.

객체에서 this는 객체 자신을 가리킨다.

---

## 3. 실행 컨텍스트

### 3.1 스코프 개념

어떠한 식별자가 유효한 범위를 가리키며 크게 전역 스코프와 지역 스코프로 구분된다.

전역 스코프는 프로젝트 전체 범위를 가리키며 javascript 파일 어느 부분에서도 사용할 수 있는 특성이 있다.

지역 스코프는 어떠한 범위 내에서만 유효하며 함수 레벨 스코프, 블록 레벨 스코프로 나뉘어진다.

함수 레벨 스코프는 어떠한 함수 내부에서 유효한 범위를 나타낸다.

블록 레벨 스코프는 { }(중괄호)로 이루어진 블록문 안에서 유효 범위를 갖는다.

스코프는 하위 스코프에서 상위 스코프로 단방향으로 연결되어 있다. 하위 스코프에서는 상위 스코프의 식별자를 참조하여 사용할 수 있지만, 상위 스코프에서는 하위 스코프의 식별자를 참조하여 사용할 수 없다.

### 3.2 이벤트 loop

자바스크립트는 싱글 스레드 기반 언어로 하나의 실행 컨텍스트로 구성되어 있어 기본적으로 소스 코드를 동기적으로 수행한다. 이때 web API, setTimeOut 등 시간이 오래 걸리는 명령을 만나면 자바스크립트는 아무런 명령도 처리하지 못하고 무한 대기하게 되는데 이러한 명령들을 비동기적으로 처리하기 위해 자바스크립트 실행 환경(web은 브라우저, 서버는 node.js)에서 task queue라는 저장 공간을 제공하는데 이벤트 loop는 자바스크립트와 실행 환경을 연결해주는 역할을 한다.

> 1. web API 등 수행이 오래 걸리는 코드를 만남
> 2. event loop가 자바스크립트 실행 환경에 있는 task queue에 명령을 enqueue
> 3. 실행 컨텍스트 스택이 모두 비워지면 event loop가 task queue에 명령이 들어온 순서대로 dequeue해 실행 컨텍스트 스택에 옮긴 후 해당 명령을 수행

### 3.3 실행 컨텍스트

자바스크립트에서 명령을 실제로 관리하고 처리하는 영역이다. 크게 전역 컨텍스트, 함수 컨텍스트, eval 컨텍스트로 나누어진다.

자바스크립트는 소스 코드를 실행하기 이전에 소스코드 평가 과정을 거치는 데 소스 코드 평가 과정에서 전역 실행 컨텍스트를 생성해 실행 컨텍스트 스택에 push하고 전역 변수와 전역 함수의 선언문을 우선적으로 수행한 후 실행 컨텍스트에 저장한다. 이후 소스 코드를 한 줄씩 해석하며 코드를 수행하고 함수 실행문을 만나면 실행 중인 명령을 일시 중단한 후 함수 코드 평가 과정에서 함수 실행 컨텍스트를 생성해 실행 컨텍스트 스택에 push한 후 함수 내부에서 사용하는 변수와 함수 등의 선언문을 실행해 실행 컨텍스트에 저장하고 함수 코드를 실행한다.

실행 컨텍스트 스택은 실행해야할 실행 컨텍스트를 순서대로 저장하는 자료구조이다. 전역 실행 컨텍스트의 명령을 수행하다가 함수 호출문을 만나면 함수 실행 컨텍스트를 push한 후 함수 내부 명령을 수행한다. 함수의 실행이 종료되면 해당 실행 컨텍스트를 pop한 후 전역 실행 컨텍스트의 명령을 이어서 수행한다.

실행 컨텍스트에 저장된 식별자, 상위 스코프의 정보, 코드의 실행 위치를 저장하는 렉시컬 환경이 존재한다. 실행 컨텍스트에서 변수를 참조할 때 현재 스코프에서 변수가 존재하는지 검색하고, 없다면 상위 스코프로 검색 범위를 확장시켜가며 변수를 검색해 사용한다.

렉시컬 스코프는 정적 스코프라고도 부르며 함수의 스코프를 결정하는 하나의 방법이다. 렉시컬 스코프는 함수의 선언 위치에 따라 상위 스코프를 결정하며 함수의 호출 위치와는 전혀 무관하게 함수 정의가 실행될 때 정적으로 결정된다. 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다.

> 1. 자바스크립트 실행 시 전역 스코프를 실행 컨텍스트 스택에 push하고 전역 코드를 수행
> 2. 함수를 만나면 수행 중인 명령을 중단하고 함수를 실행 컨텍스트 스택에 push한 후 함수 내부 명령 수행
> 3. 내부 함수를 만나면 현재 실행 중인 명령을 중단하고 내부 함수를 실행 컨텍스트 스택에 push 한 후 내부 함수 명령 수행
> 4. 내부 함수 수행이 종료되면 실행 컨텍스트 스택에서 pop 한 후 외부 함수의 명령을 이어서 수행
> 5. 외부 함수 수행이 종료되면 실행 컨텍스트 스택에서 pop 한 후 전역 명령 수행
> 6. 전역 명령 수행이 종료되면 실행 컨텍스트 스택에서 pop 한 후 프로그램 실행 종료

---

## 4. 비동기 처리

### 4.1 callback 함수

- 함수 내부에서 실행 시점을 정할 수 있다.
- es5까지 비동기 처리를 위한 유일한 방법이었다.
- 오류 처리를 위한 구문이 따로 존재하지 않는다.
- 프로젝트 규모가 커지며 비동기 작업이 중첩해서 발생할 경우 콜백 지옥에 빠지는 단점이 있다.

### 4.2 promise

- callback의 단점을 극복하기 위해 es6에서 추가된 비동기 처리 방법이다.
- 명령 수행 시점을 지정할 수 있고, 에러 처리가 가능하다.

### 4.3 async await

promise 기반의 비동기 처리 방법으로 promise 보다 더 간편하게 사용할 수 있다.

### 4.3 api 처리

서버에 api 요청 -> 응답 이후 명령 수행

---

## 5. 가비지 컬렉터

기존의 개발자가 하던 메모리 관리를 프로그래밍 언어가 대신 해주기 위한 도구를 말한다. 대표적으로 Reference Counting, Mark & Sweep 이 있다.

1. Reference Counting

   - 선언하는 모든 식별자는 Reference Count를 가지고 해당 식별자를 참조하는 개수를 저장한다. Reference Count가 0이 되면 해당 식별자가 더 이상 필요없다고 간주하고 메모리 공간에서 할당을 해제한다.
   - 서로가 서로를 참조하는 순환 참조의 경우 식별자의 스코프를 벗어나 더 이상 해당 식별자를 참조할 수 없음에도 Reference Count는 0이 아니기 때문에 메모리 공간에서 할당이 해제되지 않는다. 즉, 순환 참조되는 식별자는 Reference Counting 방식으로 가비지 컬렉션을 완벽하게 구현할 수 없다.

2. Mark & Sweep
   - 모든 데이터를 연결하는 가장 기본 노드인 root 노드가 존재한다.
   - root 노드에서 시작해서 유효한 스코프 내에 있는 식별자, 현재 사용하고 있는 식별자를 root와 연결한다(Marking)
   - 모든 데이터를 순회하며 marking 되어있지 않은 식별자의 할당을 해제한다.(Sweep)
   - 순환 참조하는 식별자도 식별자 유효 범위를 벗어나 root와 연결될 수 없다면 메모리 할당을 해제할 수 있다.
   - 컨셉은 간단하지만 최적화 정도에 따라서 어플리케이션 성능에 영향을 줄 수 있다.
